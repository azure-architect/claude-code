# Claude Code Integration Workflow

This guide explains how to effectively use Claude Code with this Python template for maximum productivity.

## ü§ñ Claude Code Commands

### Available Template Commands

#### `/implement <task>` - Structured Implementation
```bash
# Examples:
/implement "Create a user authentication system with JWT tokens"
/implement "Build a data validation pipeline with custom rules"
/implement "Add rate limiting middleware to FastAPI application"
```

**What Claude Code will do:**
- Analyze the task requirements
- Plan implementation with proper architecture
- Create code following template patterns
- Enforce type annotations and documentation
- Follow security best practices
- Integrate with existing codebase structure

#### `/test <component>` - Comprehensive Testing
```bash
# Examples:
/test "src/auth.py"
/test "src/api/users.py"
/test "Complete authentication system"
```

**What Claude Code will do:**
- Analyze code structure and dependencies
- Generate unit tests for all methods
- Create integration tests where appropriate
- Include edge cases and error conditions
- Use pytest fixtures and best practices
- Achieve 90%+ test coverage

#### `/document <component>` - Documentation Generation
```bash
# Examples:
/document "src/database.py"
/document "API authentication system"
/document "Data processing pipeline"
```

**What Claude Code will do:**
- Generate comprehensive docstrings
- Create usage examples
- Document configuration options
- Include troubleshooting guides
- Follow Google/Sphinx docstring format

## üîÑ Development Workflow with Claude Code

### 1. Feature Planning Phase

**Human Input:**
```
I need to add a caching layer to my API to improve performance. 
It should support Redis, in-memory cache, and have configurable TTL.
```

**Claude Code Response:**
```bash
# Use the implement command for planning
/implement "Add configurable caching layer with Redis and in-memory options"
```

**Claude Code will:**
- Break down the feature into components
- Design interfaces and classes
- Plan configuration structure
- Consider error handling and edge cases
- Create implementation roadmap

### 2. Implementation Phase

**Step-by-step with Claude Code:**

```python
# Claude Code will create structure like this:
# src/cache/
#   ‚îú‚îÄ‚îÄ __init__.py
#   ‚îú‚îÄ‚îÄ base.py          # Abstract cache interface
#   ‚îú‚îÄ‚îÄ redis_cache.py   # Redis implementation
#   ‚îú‚îÄ‚îÄ memory_cache.py  # In-memory implementation
#   ‚îî‚îÄ‚îÄ config.py        # Cache configuration
```

**Example Output:**
```python
# src/cache/base.py (Generated by Claude Code)
"""Abstract cache interface."""

from abc import ABC, abstractmethod
from typing import Any, Optional, Union
import asyncio


class CacheBackend(ABC):
    """Abstract base class for cache backends."""
    
    @abstractmethod
    async def get(self, key: str) -> Optional[Any]:
        """Get value from cache."""
        pass
    
    @abstractmethod
    async def set(self, key: str, value: Any, ttl: Optional[int] = None) -> bool:
        """Set value in cache with optional TTL."""
        pass
    
    @abstractmethod
    async def delete(self, key: str) -> bool:
        """Delete key from cache."""
        pass
    
    @abstractmethod
    async def clear(self) -> bool:
        """Clear all cache entries."""
        pass
```

### 3. Testing Phase

**Claude Code Test Generation:**
```bash
/test "src/cache/"
```

**Generated Test Structure:**
```python
# tests/test_cache.py (Generated by Claude Code)
"""Comprehensive cache backend tests."""

import pytest
import asyncio
from unittest.mock import AsyncMock, patch

from src.cache.memory_cache import MemoryCache
from src.cache.redis_cache import RedisCache
from src.cache.config import CacheConfig


@pytest.fixture
def cache_config():
    """Cache configuration for testing."""
    return CacheConfig(
        backend="memory",
        ttl_default=300,
        max_entries=1000
    )


@pytest.fixture
async def memory_cache(cache_config):
    """Memory cache instance for testing."""
    cache = MemoryCache(cache_config)
    yield cache
    await cache.clear()


class TestMemoryCache:
    """Test memory cache backend."""
    
    @pytest.mark.asyncio
    async def test_set_and_get(self, memory_cache):
        """Test basic set and get operations."""
        await memory_cache.set("test_key", "test_value")
        result = await memory_cache.get("test_key")
        assert result == "test_value"
    
    @pytest.mark.asyncio
    async def test_ttl_expiration(self, memory_cache):
        """Test TTL expiration functionality."""
        await memory_cache.set("ttl_key", "ttl_value", ttl=1)
        
        # Should exist immediately
        result = await memory_cache.get("ttl_key")
        assert result == "ttl_value"
        
        # Should expire after TTL
        await asyncio.sleep(1.1)
        result = await memory_cache.get("ttl_key")
        assert result is None
    
    @pytest.mark.asyncio
    async def test_delete_key(self, memory_cache):
        """Test key deletion."""
        await memory_cache.set("delete_key", "delete_value")
        await memory_cache.delete("delete_key")
        
        result = await memory_cache.get("delete_key")
        assert result is None
```

### 4. Documentation Phase

**Claude Code Documentation:**
```bash
/document "Cache system implementation"
```

**Generated Documentation:**
```python
"""
# Cache System Documentation

## Overview
The cache system provides a flexible, async-first caching layer with multiple backend options.

## Supported Backends
- **Memory Cache**: Fast in-memory caching for single-instance applications
- **Redis Cache**: Distributed caching for multi-instance applications

## Configuration
```python
from src.cache.config import CacheConfig

config = CacheConfig(
    backend="redis",
    redis_url="redis://localhost:6379",
    ttl_default=300,
    max_entries=10000
)
```

## Usage Examples
```python
from src.cache import CacheManager

# Initialize cache
cache = CacheManager(config)

# Basic operations
await cache.set("user:123", user_data, ttl=600)
user = await cache.get("user:123")
await cache.delete("user:123")
```

## Error Handling
The cache system handles connection failures gracefully:
- Redis connection errors fall back to local cache
- TTL validation prevents memory leaks
- Automatic cleanup of expired entries
"""
```

## üõ°Ô∏è Claude Code Validation Hooks

### Pre-tool Validation

The template includes sophisticated validation that runs before Claude Code writes files:

#### Code Quality Enforcement
```python
# ‚úÖ This will pass validation:
def process_data(items: List[str]) -> Dict[str, int]:
    """Process items and return counts."""
    return {item: len(item) for item in items}

# ‚ùå This will be blocked:
def process_data(items):  # Missing type annotations
    return {item: len(item) for item in items}
```

#### Security Pattern Enforcement
```python
# ‚ùå This will be blocked:
import os
os.system("curl https://api.example.com")  # Insecure

# ‚úÖ This will pass:
import subprocess
subprocess.run(["curl", "https://api.example.com"], check=True)
```

#### File Length Limits
```python
# ‚ùå Files over 500 lines are blocked
# Claude Code will suggest breaking into smaller modules

# ‚úÖ Keep modules focused and under 500 lines
```

#### Email Client Security
```python
# ‚ùå This will be blocked:
import smtplib
smtp = smtplib.SMTP('smtp.gmail.com', 587)  # No SSL

# ‚úÖ This will pass:
import smtplib
import ssl
context = ssl.create_default_context()
smtp = smtplib.SMTP('smtp.gmail.com', 587)
smtp.starttls(context=context)
```

### Post-tool Formatting

After Claude Code writes files, hooks automatically:
- Format code with Black
- Sort imports with isort
- Add missing imports
- Fix common style issues

## üí° Advanced Claude Code Patterns

### 1. Iterative Development

**Pattern: Build ‚Üí Test ‚Üí Refine**
```bash
# Initial implementation
/implement "Basic user registration with email validation"

# Add features iteratively  
/implement "Add password strength validation to user registration"

# Enhance with tests
/test "src/auth/registration.py"

# Document the complete system
/document "User registration system"
```

### 2. Code Review and Improvement

**Pattern: Analyze ‚Üí Suggest ‚Üí Implement**
```
Human: "This auth code works but feels messy. Can you clean it up?"

Claude Code: 
- Analyzes existing code structure
- Suggests refactoring opportunities
- Implements improvements while preserving functionality
- Adds missing tests for edge cases
```

### 3. Integration Development

**Pattern: Plan Interfaces ‚Üí Implement Components ‚Üí Integration Tests**
```bash
# Design system interfaces first
/implement "Design interfaces for payment processing system"

# Implement individual components
/implement "Stripe payment processor implementation"
/implement "PayPal payment processor implementation"  

# Create integration tests
/test "Complete payment processing system with multiple providers"
```

### 4. Performance Optimization

**Pattern: Profile ‚Üí Optimize ‚Üí Validate**
```
Human: "My API is slow. Help me optimize it."

Claude Code:
- Analyzes code for performance bottlenecks
- Suggests specific optimizations (caching, async, database queries)
- Implements improvements with benchmarks
- Adds performance tests to prevent regression
```

## üöÄ Productivity Tips

### 1. Context Sharing
When working with Claude Code, provide context:
```
"I'm building a FastAPI application with PostgreSQL. The user model is in src/models/user.py. 
I need to add password reset functionality that sends emails and expires tokens after 1 hour."
```

### 2. Incremental Requests
Break large features into smaller requests:
```bash
# Instead of: "Build a complete e-commerce system"
# Do this:
/implement "Product catalog with categories and search"
/implement "Shopping cart with session management"  
/implement "Checkout process with payment integration"
```

### 3. Leverage Template Patterns
Reference existing code patterns:
```
"Follow the same pattern as the authentication system in src/auth.py but for user permissions."
```

### 4. Quality Gates
Use Claude Code for quality assurance:
```bash
# Before committing
/test "Complete feature implementation"
/document "New feature for end users"

# Run quality check
./scripts/qa_check.sh
```

## üîç Debugging with Claude Code

### 1. Error Analysis
```
Human: "Getting this error: [paste error]"

Claude Code:
- Analyzes stack trace
- Identifies root cause
- Suggests specific fixes
- Implements solution with error handling
```

### 2. Code Explanation
```
Human: "Explain how this caching system works"

Claude Code:
- Traces code execution flow
- Explains design decisions
- Documents interfaces and interactions
- Suggests improvements
```

### 3. Performance Investigation
```
Human: "Why is this query slow?"

Claude Code:
- Analyzes database queries
- Suggests indexing strategies
- Implements query optimizations
- Adds monitoring and logging
```

## üìä Measuring Success

### Quality Metrics
- **Test Coverage**: Maintain 90%+ with Claude Code generated tests
- **Type Coverage**: 100% type annotations enforced by hooks
- **Security Score**: Clean bandit scans with security patterns
- **Documentation**: Complete API documentation with examples

### Development Speed
- **Feature Velocity**: Faster implementation with Claude Code assistance
- **Bug Reduction**: Fewer bugs with comprehensive testing
- **Onboarding**: New developers productive faster with documentation
- **Maintenance**: Easier refactoring with well-structured code

## üéØ Best Practices Summary

1. **Start with Planning**: Use `/implement` for feature design
2. **Test Early**: Use `/test` during development, not after
3. **Document Continuously**: Use `/document` for complex systems
4. **Leverage Hooks**: Let validation guide code quality
5. **Iterate Quickly**: Build small, test, repeat
6. **Share Context**: Provide Claude Code with relevant information
7. **Follow Patterns**: Maintain consistency across codebase
8. **Quality First**: Use automation to enforce standards

This workflow ensures you get maximum value from Claude Code while building high-quality, maintainable Python applications! üöÄ